using Compiler;
using System.Collections.Generic;

COMPILER Syntax

    public ProgramNode RootNode;



/*--------------------------------------------------------------------------------------*/

IGNORECASE

CHARACTERS
    whitespace      = " \t" .
    newline         = "\r\n" .
    notNewline      = ANY - newline .
    quote           = '"' .
    notQuote        = ANY - newline - '"' .
    digit           = "0123456789" .
    letter          = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_" .

TOKENS
    comment         = "//" {notNewline} .
    identifier      = letter {letter | digit} .
    func            = "func" .
    print           = "print" .
    return          = "return" .
    continue        = "continue" .
    break           = "break" .
    if              = "if" .
    then            = "then" .
    else            = "else" .
    endif           = "endif" .
    while           = "while" .
    do              = "do" .
    done            = "done" .
    var             = "var" .
    assignment      = "=" .
    equal           = "==" .
    notEqual        = "!=" .
    leq             = "<=" .
    geq             = ">=" .
    divide          = "/" .
    integer         = digit {digit} .
    string          = quote {notQuote} quote .
    
IGNORE
    "\t" + newline



/*--------------------------------------------------------------------------------------*/
 
PRODUCTIONS

Syntax = (                      (. FunctionNode f; RootNode = new ProgramNode(); .)
    Function<out f>             (. RootNode.Functions.Add(f); .)
    {
        Function<out f>         (. RootNode.Functions.Add(f); .)
    }
).

Function<out FunctionNode f> = (    (. IdentifierNode i; .)
    func 
    Identifier<out i>               (. f = new FunctionNode(i); .)
    '(' [
        Identifier<out i>           (. f.Parameters.Add(i); .)
        {
            ',' Identifier<out i>   (. f.Parameters.Add(i); .)
        }
    ] ')'
    Block<out b>                    (. f.Body = b; .)
).

Identifier<out IdentifierNode i> = (
    identifier  (. i = new IdentifierNode(t.val); .)
).

Block<out BlockNode b> = (          (. DeclarationNode d; StatementNode s; b = new BlockNode(); .)
    '{'
        {
            Declaration<out d>      (. b.Declarations.Add(d); .)
        }
        {
            Statement<out s>        (. b.Statements.Add(s); .)
        }
    '}'
).

Declaration<out DeclarationNode d> = (  (. IdentifierNode i; d = new DeclarationNode(); .)
    var Identifier<out i>               (. d.Variables.Add(i); .)
    {
        "," Identifier<out i>           (. d.Variables.Add(i); .) 
    }
).

Statement<out StatementNode s> = (  (. AssignmentStatementNode a; ReturnStatementNode r; PrintStatementNode p; NullStatementNode n; IfStatementNode i; WhileStatementNode w; BlockStatementNode b; .)
    AssignmentStatement<out a>      (. s = a; .)
    | ReturnStatement<out r>        (. s = r; .)
    | PrintStatement<out p>         (. s = p; .)
    | NullStatement<out n>          (. s = n; .)
    | IfStatement<out i>            (. s = i; .)
    | WhileStatement<out w>         (. s = w; .)
    | Block<out b>                  (. s = b; .)
).

AssignmentStatement<out AssignmentStatementNode a> = (  (. IdentifierNode i; ExpressionNode e; .)
    Identifier<out i> assignment Expression<out e>      (. a = new AssignmentStatementNode(v, e); .)
).

ReturnStatement<out ReturnStatementNode r> = (  (. ExpressionNode e; .)
    return Expression<out e>                    (. r = new ReturnStatementNode(e); .)
).

PrintStatement<out PrintStatementNode p> = (    (. IPrintItemNode pi; p = new PrintStatementNode(); .)
    print PrintItem<out pi>                     (. p.Items.Add(pi); .)
    {
        "," PrintItem<out pi>                   (. p.Items.Add(pi); .)
    }
).

NullStatement<out NullStatementNode n> = (  (. NullStatementNode n; .)
    continue                                (. n = new NullStatementNode(NullStatementType.Continue); .)
    | break                                 (. n = new NullStatementNode(NullStatementType.Break); .)
).

PrintItem<out IPrintItemNode p> = ( (. ExpressionNode e; StringNode s; .)
    Expression<out e>               (. p = e; .)
    | String<out s>                 (. p = s; .)
).

String<out StringNode s> = (
    string                      (. s = new StringNode(t.val); .)
).

Integer<out IntegerNode i> = (
    integer                     (. i = new IntegerNode(t.val); .)
).

IfStatement<out IfStatementNode i> = (  (. Expression condition; Statement thenBody; Statement elseBody = null; .)
    if Expression<out condition> 
    then Statement<out thenBody> 
    [
        else Statement<out elseBody>
    ]
    endif                               (. i = new IfStatementNode(condition, thenBody, elseBody); .)
).

WhileStatement<out WhileStatementNode w> = (                    (. Expression condition; Statement body; .)
    while Expression<out condition> do Statement<out body> done (. w = new WhileStatementNode(condition, body); .)
).

Expression<out ExpressionNode e> = (                            (. ExpressionNode left, right, child; IntegerNode i; .)
      Expression<out left> '+'      Expression<out right>       (. e = new BinaryExpressionNode(left, Operator.Add, right); .)
    | Expression<out left> '-'      Expression<out right>       (. e = new BinaryExpressionNode(left, Operator.Subtract, right); .)
    | Expression<out left> '*'      Expression<out right>       (. e = new BinaryExpressionNode(left, Operator.Multiply, right); .)
    | Expression<out left> '/'      Expression<out right>       (. e = new BinaryExpressionNode(left, Operator.Divide, right); .)
    | Expression<out left> equal    Expression<out right>       (. e = new BinaryExpressionNode(left, Operator.Equal, right); .)
    | Expression<out left> notEqual Expression<out right>       (. e = new BinaryExpressionNode(left, Operator.NotEqual, right); .)
    | Expression<out left> '<'      Expression<out right>       (. e = new BinaryExpressionNode(left, Operator.LessThan, right); .)
    | Expression<out left> leq      Expression<out right>       (. e = new BinaryExpressionNode(left, Operator.LessThanOrEqual, right); .)
    | Expression<out left> '>'      Expression<out right>       (. e = new BinaryExpressionNode(left, Operator.GreaterThan, right); .)
    | Expression<out left> geq      Expression<out right>       (. e = new BinaryExpressionNode(left, Operator.GreaterThanOrEqual, right); .)
    | '-' Expression<out child>                                 (. e = new UnaryExpressionNode(Operator.Subtract, child); .)
    | '(' Expression<out child> ')'                             (. e = child; .)
    | Integer<out i>                                            (. e = new ConstantExpressionNode(i); .)
    | Identifier<out name>                                      (. e = new VariableReferenceNode(id); .)
      [                                                         (. e = f = new FunctionCallNode(name); .)
        '(' [
            Expression<out arg>                                 (. f.Arguments.Add(arg); .)
            {
                ',' Expression<out arg>                         (. f.Arguments.Add(arg); .)
            }
        ] ')'
      ]
).

END Syntax .
